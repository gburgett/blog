<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Gordon Burgett | Director of Technology Development</title><link>http://www.gordonburgett.net/posts/</link><description>Recent content in Posts on Gordon Burgett | Director of Technology Development</description><generator>Hugo</generator><language>en</language><copyright>All content Â© Gordon Burgett, 2014-2024</copyright><lastBuildDate>Sat, 16 Nov 2024 10:00:00 -0500</lastBuildDate><atom:link href="http://www.gordonburgett.net/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Building an Unstructured Data Import</title><link>http://www.gordonburgett.net/posts/2024/11_neighbor-solutions-import/</link><pubDate>Sat, 16 Nov 2024 10:00:00 -0500</pubDate><guid>http://www.gordonburgett.net/posts/2024/11_neighbor-solutions-import/</guid><description>&lt;p>Sometimes the hardest thing to figure out is not &amp;ldquo;how&amp;rdquo; to best apply a new technology, but &amp;ldquo;when not&amp;rdquo; to apply it.
Nowhere has this been more true than with AI. With the rush to stick the AI brand on every project, software engineers
are being pressured to &amp;ldquo;just throw more AI&amp;rdquo; at the problem and hope it works.&lt;/p>
&lt;p>In my hourly contracting on &lt;a href="https://neighbor.solutions/">Neighbor Solutions&lt;/a>, I&amp;rsquo;ve been asked to build a data import
pipeline for community resources. To give a bit of context, one core function of the Neighbor Solutions app is to
help users who have a heart for our unhoused neighbors to guide them towards helpful resources in their community. These
can be food banks, shelters, warming stations, and many more. The major technical difficulty here is getting accurate
data into the system in an automated way. Many times, lists of these resources are in poorly formatted PDFs or screenshots
of webpages. There is very little consistency here, so some amount of natural language processing is required.&lt;/p></description></item><item><title>Implementing Licensing &amp; Permissions in a React Redux app</title><link>http://www.gordonburgett.net/posts/2024/10_voir-dire-licensing-modal/</link><pubDate>Sun, 20 Oct 2024 10:00:00 -0500</pubDate><guid>http://www.gordonburgett.net/posts/2024/10_voir-dire-licensing-modal/</guid><description>&lt;p>In the process of building out the &lt;a href="https://www.voirdire.app/">VoirDire App&lt;/a> for our client, we ran into an interesting
problem. How do we enforce licensing requirements in a cross-cutting way, without tediously identifying every area
in the UI where the user might take an action that they were not allowed to take? The client&amp;rsquo;s licensing requirements
were:&lt;/p>
&lt;ul>
&lt;li>On the free plan, a user can have 1 trial, up to 20 jurors, and up to 20 stored questions.&lt;/li>
&lt;li>With a standard license ($30), up to trials, 100 jurors, and 100 stored questions.&lt;/li>
&lt;li>An unlimited license ($50) removes all limitations.&lt;/li>
&lt;/ul>
&lt;p>Since we are using Redux to handle application state, calculating the remaining jurors, trials, etc. in the license can
be done with a selector. The selector accepts the entire redux state and the user&amp;rsquo;s current license key, then calculates
whether they are over or under the limit.&lt;/p></description></item><item><title>Thoughts on Cursor</title><link>http://www.gordonburgett.net/posts/2024/09_thoughts-on-cursor/</link><pubDate>Fri, 20 Sep 2024 10:00:00 -0500</pubDate><guid>http://www.gordonburgett.net/posts/2024/09_thoughts-on-cursor/</guid><description>&lt;p>As AI tools continue to reshape software development, I&amp;rsquo;ve been particularly impressed with Cursor, an AI-powered code editor that has transformed my daily workflow. After several months of use, I want to share my experiences and observations about why this tool has become indispensable in my development process.&lt;/p>
&lt;p>The most striking impact of Cursor has been the dramatic increase in my productivity - I estimate it has doubled my coding speed.
The secret sauce that Cursor has nailed is the UX around applying suggested edits back to my codebase.
The experience feels natural, almost like dictating your thoughts to a junior developer who then implements the code exactly as you envision it.&lt;/p></description></item></channel></rss>